import type { Plugin } from "vite";
import * as path from "path";
import island from "vite-plugin-island";
import { findChunk, findRenderChunk, getOutputAsset } from "./bundle.js";
import {
  emitBuildInfo,
  stripModulePreloadLinks,
  importServerEntry,
  getServerEntryScript,
} from "./utils.js";
import { readFile } from "fs/promises";
import { prerender } from "./prerender.js";
import { CapriOptions } from "./types.js";

export { hasPlugin } from "./utils.js";
export * from "./types.js";

export default function capri({
  islandGlobPattern = "/src/**/*.island.*",
  appHtmlPlaceholder = "<!--app-html-->",
  createIndexFiles = true,
  hydrate,
  renderMarkerFragment,
  spa,
}: CapriOptions): Plugin[] {
  let mode: "client" | "server" | "spa";
  let ssr: string;
  return [
    island({
      islandGlobPattern,
      hydrate,
      renderMarkerFragment,
    }),
    {
      name: "vite-plugin-capri",

      // make sure index.html has already been emitted:
      enforce: "post",

      config(config, { command }) {
        if (config.build?.ssr) {
          mode = "server";
        } else if (command === "serve") {
          // running in dev server
          mode = "spa";
        } else {
          mode = "client";
        }

        if (mode === "server") {
          ssr = getServerEntryScript(config);
          return {
            build: {
              ssr,
              emptyOutDir: false, // keep the client build
              rollupOptions: {
                output: {
                  // Generate the node code as ES module.
                  // Using ESM everywhere is a lot easier than mixing module types.
                  format: "es",
                },
              },
            },
          };
        }
      },
      async buildStart(options) {
        if (mode === "client") {
          // Generate the island hydration code.
          this.emitFile({
            id: "virtual:island-hydration",
            type: "chunk",
            name: "hydrate",
          });
        }
      },
      async generateBundle(options, bundle) {
        if (mode === "client") {
          const index = getOutputAsset(bundle, "index.html");
          const entry = findChunk(bundle, "index.html");

          // Generate a JSON file with meta data about this build
          emitBuildInfo(this);

          // Look up the hydration chunk
          const resolved = await this.resolve("virtual:island-hydration");
          const hydration = findChunk(bundle, resolved!.id);

          if (spa) {
            // Generate a single page version of the app.
            // This is the index.html as it was generated by the client build.
            this.emitFile({
              type: "asset",
              fileName: spa,
              source: index.source.replace(appHtmlPlaceholder, ""),
            });
          }

          // Finally generate the template for our server build.
          // We therefore replace the SPA entry script with the hydration script.
          // We also strip any module preload links generated during the client build
          // as these would load parts of the application we don't need.
          index.source = stripModulePreloadLinks(index.source).replace(
            entry.fileName,
            hydration.fileName
          );
        }
        if (mode === "server") {
          const chunk = findRenderChunk(bundle, ssr);

          // Remove the ssr chunk from the bundle as we don't want it to be written to disk.
          delete bundle[chunk.fileName];

          // Read the index.html so we can use it as template for all prerendered pages.
          const indexHtml = await readFile(
            path.join(options.dir!, "index.html"),
            "utf8"
          );

          // Import the render function from the SSR bundle.
          const { render, getStaticPaths } = await importServerEntry(
            chunk,
            options.dir!
          );

          // Prerender pages...
          const staticPaths: string[] = getStaticPaths
            ? await getStaticPaths()
            : ["/"];

          await prerender(staticPaths, render, {
            template: indexHtml,
            outDir: options.dir!,
            createIndexFiles,
            appHtmlPlaceholder,
          });
        }
      },
    },
  ];
}
