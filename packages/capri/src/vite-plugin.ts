import micromatch from "micromatch";
import * as path from "path";
import type {
  OutputAsset,
  OutputBundle,
  OutputChunk,
  PluginContext,
  RollupOptions,
} from "rollup";
import type { ConfigEnv, Plugin, SSROptions, UserConfig } from "vite";

import { BundleOptions, createBundler } from "./bundle.js";
import { EntryScripts, getEntryScripts } from "./entry.js";
import * as fsutils from "./fsutils.js";
import {
  FollowLinksConfig,
  PrerenderConfig,
  renderStaticPages,
  urlToFileName,
} from "./prerender.js";
import { addUnwrapped } from "./utils.js";

export interface Wrapper {
  server?: string;
  client?: string;
}
export interface Adapter {
  hydrate: string;
  island: Wrapper;
  lagoon: Wrapper;
  injectWrapper?: "onLoad" | "onTransform";
}

export interface BuildArgs {
  rootDir: string;
  outDir: string;
  ssrBundle: string;
  prerendered: string[];
  fsutils: typeof fsutils;
  bundle: (
    input: string,
    output: string,
    options?: BundleOptions
  ) => Promise<void>;
}

interface ViteConfig extends UserConfig {
  ssr?: SSROptions;
}
export interface BuildTarget {
  config?: (
    config: ViteConfig,
    env: ConfigEnv
  ) => ViteConfig | null | void | Promise<ViteConfig | null | void>;
  build: (args: BuildArgs) => Promise<void>;
}
export interface CapriPluginOptions {
  createIndexFiles?: boolean;
  prerender?: PrerenderConfig;
  followLinks?: FollowLinksConfig;
  islandGlobPattern?: string;
  lagoonGlobPattern?: string;
  adapter: Adapter;
  target?: BuildTarget | string;
  spa?: string | false;
}

export type CapriAdapterPluginOptions = Omit<CapriPluginOptions, "adapter">;

export function capri({
  createIndexFiles = true,
  prerender = "/",
  followLinks = true,
  islandGlobPattern = "/src/**/*.island.*",
  lagoonGlobPattern = "/src/**/*.lagoon.*",
  adapter,
  target,
  spa,
}: CapriPluginOptions): Plugin[] {
  const ssr = resolveRelative("./virtual/ssr.js");

  let ssrBuild: boolean;

  let entry: EntryScripts;

  const serverAssets: OutputBundle = {};

  /** The project's root directory as defined in Vite config or the cwd */
  let rootDir: string;

  /** Absolute path of the build output dir */
  let outDir: string;

  /** The BASE_URL */
  let base: string;

  /** The content of index.html as generated by the client build */
  let template: string;

  const { injectWrapper = "onLoad" } = adapter;

  const buildTarget = typeof target === "object" ? target : undefined;

  /**
   * Test if id matches the given pattern and set the meta data accordingly.
   */
  function resolveWrapper(id: string, pattern: string, wrapper: Wrapper) {
    // Exclude sources that contain "?", e.g. vue styles and setup scripts
    if (!id.includes("?") && micromatch.contains(id, pattern)) {
      return {
        id,
        meta: { wrapper, wrapped: id },
      };
    }
  }

  /**
   * Load the wrapper as requested in the meta data.
   * In the wrapper code, two replacements are applied:
   *
   * - "virtual:capri-component" -> the wrapped module + "?unwrapped"
   * - "%COMPONENT_ID%" -> the Id of the wrapped component (relative to the root)
   */
  function loadWrapper(
    meta: { wrapper: Wrapper; wrapped: string },
    server = ssrBuild
  ) {
    const { wrapper, wrapped } = meta;

    const unwrappedId = addUnwrapped(wrapped);

    const componentId = wrapped.startsWith(rootDir)
      ? wrapped.slice(rootDir.length)
      : wrapped;

    const wrapperFile = wrapper[server ? "server" : "client"];
    if (wrapperFile) {
      const code = fsutils.read(wrapperFile);
      return code
        .replace(/virtual:capri-component/g, unwrappedId)
        .replace(/%COMPONENT_ID%/g, componentId);
    }
  }

  return [
    /**
     * Allow build targets to modify the config
     */
    {
      // Needs to run before the main plugin
      enforce: "pre",
      name: "vite-plugin-capri-target",
      config: buildTarget?.config,
    },

    /**
     * The main Capri plugin.
     */
    {
      enforce: "pre", // modify the bundle before vite:build-html runs
      name: "vite-plugin-capri-main",

      config(config, env) {
        ssrBuild = !!config.build?.ssr;

        rootDir = path.resolve(config.root ?? "");
        outDir = path.resolve(rootDir, config.build?.outDir ?? "dist");

        entry = getEntryScripts(rootDir);

        // Allow base to be set via env:
        base = config.base ?? process.env.BASE_URL ?? "/";

        if (spa)
          spa = path.resolve(
            rootDir,
            urlToFileName(spa, createIndexFiles, base)
          );

        if (ssrBuild) {
          // Read the index.html produced by the client build, so we can use it
          // as template for all pre-rendered pages.
          const indexHtml = path.join(outDir, "index.html");
          template = fsutils.read(indexHtml);
          fsutils.rm(indexHtml);

          return {
            base,
            define: {
              "process.env.SSR": "true",
            },
            ssr: {
              // The capri packages can't be externalized as they need to be
              // processed by Vite (virtual modules and glob imports).
              noExternal: ["capri", /@capri-js\//],
            },
            build: {
              ssr,
              emptyOutDir: false, // keep the client build
            },
          };
        } else {
          // Client build ...
          let rollupOptions: RollupOptions = {};
          if (!entry.client) {
            // index.html points to a .server.* file
            if (spa) {
              throw new Error(
                "In order to generate an SPA, index.html must point to a client entry file."
              );
            }
          } else if (spa) {
            // Generate two entry chunks:
            rollupOptions = {
              input: {
                index: "/index.html",
                spa,
              },
            };
          }
          return {
            base,
            build: {
              rollupOptions,
              modulePreload: {
                // Setting modulePreload to `false` does not work as expected.
                // As workaround, we provide a no-op resolver:
                resolveDependencies(f, deps, context) {
                  return [];
                },
              },
            },
          };
        }
      },

      /**
       * Hook to resolve some virtual modules and, most importantly, wrap
       * islands and lagoons with the code provided by the framework adapter.
       */
      async resolveId(source, importer, options) {
        if (source === spa) {
          // The spa file is not a real file but will be handled by load().
          // Return the virtual path as-is:
          return spa;
        }

        if (source === "virtual:capri-hydration") {
          // The hydration script. This is also a virtual module that will be
          // handled by load().
          return { id: "\0virtual:capri-hydration", moduleSideEffects: true };
        }

        if (source === "virtual:capri-hydration-adapter") {
          // Framework adapters provide a module for the actual hydration ...
          return this.resolve(adapter.hydrate);
        }

        if (source === "virtual:capri-server-entry") {
          // This is used by ./virtual/ssr.ts to import the server entry ...
          return entry.server;
        }

        if (source.includes("?unwrapped")) {
          // The unmodified version of a module is requested, nothing to do ...
          return;
        }

        // Try to resolve the requested module
        const resolved = await this.resolve(source, importer, {
          ...options,
          skipSelf: true,
        });

        if (resolved) {
          if (resolved.id === entry.client || resolved.id === entry.server) {
            // Use the wrapper mechanism to make sure that clients always get
            // the hydration script as entry:
            return resolveWrapper(resolved.id, "*", {
              client: resolveRelative("./virtual/client.js"),
            });
          }

          // Wrap islands and lagoons ...
          return (
            resolveWrapper(resolved.id, islandGlobPattern, adapter.island) ??
            resolveWrapper(resolved.id, lagoonGlobPattern, adapter.lagoon)
          );
        }
      },

      /**
       * Hook to modify some of the files we are interested in.
       */
      async load(id) {
        if (id === spa) {
          // Load the preview html file, aka the SPA version of our site.
          // That file itself does not exist. Instead we return the actual
          // index.html, but with a rewritten entry script path.
          const index = await resolveIndexHtml(this);

          // ... we add ?unwrapped to the entry script path so that the
          // original version is used and not the hydration script:
          const rewritten = addUnwrapped(entry.raw);

          return fsutils.read(index).replace(entry.raw, rewritten);
        }

        if (id === "\0virtual:capri-hydration") {
          // Load the hydration script and inject the `islandGlobPattern`.
          const file = resolveRelative("./virtual/hydration.js");
          return fsutils
            .read(file)
            .replace(/%ISLAND_GLOB_PATTERN%/g, islandGlobPattern);
        }

        if (id === ssr) {
          // Load the virtual ssr module and inject the index.html
          return fsutils
            .read(ssr)
            .replace('"%TEMPLATE%"', JSON.stringify(template));
        }
      },

      async writeBundle(options, bundle) {
        if (ssrBuild) {
          const ssrBundle = path.resolve(outDir, "ssr.js");

          // Prerender pages...
          const prerendered = await renderStaticPages({
            ssrBundle,
            createIndexFiles,
            outDir,
            base,
            prerender,
            followLinks,
          });

          // Hook for build targets
          if (buildTarget) {
            await buildTarget.build({
              rootDir,
              outDir,
              ssrBundle,
              prerendered,
              fsutils,
              bundle: createBundler(ssrBundle),
            });
          } else if (typeof target === "string") {
            fsutils.copy(ssrBundle, await resolveFile(this, target));
          }
          fsutils.rm(ssrBundle);
        }
      },
    },

    /**
     * Vite does not emit assets for SSR builds, assuming that they are emitted
     * by the client build. For Capri, this is only the case if we are building
     * the preview SPA, which is optional. Normally, the client build will only
     * include the islands and the hydration code. We therefore add this plugin
     * to save the server assets so that we can restore them later on (see next
     * plugin).
     */
    {
      enforce: "pre",
      name: "capri-save-assets",
      generateBundle(options, bundle) {
        if (ssrBuild) {
          for (const file in bundle) {
            const chunk = bundle[file];
            if (chunk.type === "asset" && !file.includes("ssr-manifest.json")) {
              serverAssets[file] = chunk;
            }
          }
        }
      },
    },

    /**
     * This plugin restores the assets that were saved by the previous one and
     * were meanwhile deleted by Vite's asset plugin:
     * https://github.com/vitejs/vite/blob/f12a1ab/packages/vite/src/node/plugins/asset.ts#L189
     */
    {
      enforce: "post",
      name: "capri-restore-assets",
      generateBundle(options, bundle) {
        if (ssrBuild) {
          // Add the assets back to the bundle so that Vite will emit the files
          Object.assign(bundle, serverAssets);

          const css = getCssUrls(serverAssets, base);
          const ssrChunk = getSSRChunk(bundle);

          // We have to rewrite the code here, after the bundling has finished.
          // If the chunk had a source map, this would mess it up and we would
          // need to use a library like magic-string.
          // For now this naive approach seems fine.
          ssrChunk.code = ssrChunk.code.replace(
            "__CSS_ASSETS__",
            JSON.stringify(css)
          );
        }
      },
    },

    /**
     * Plugin to load the wrapper code. Depending on the UI framework, this
     * needs to happen inside the `load` or the `transform` hook.
     */
    injectWrapper === "onLoad"
      ? {
          name: "capri-load",
          load(id, options) {
            const info = this.getModuleInfo(id);
            if (isWrapperInfo(info)) {
              return loadWrapper(info.meta, options?.ssr);
            }
          },
        }
      : {
          name: "capri-transform",
          enforce: "post",
          transform(code, id, options) {
            const info = this.getModuleInfo(id);
            if (isWrapperInfo(info)) {
              return loadWrapper(info.meta, options?.ssr);
            }
          },
        },
  ];
}

function resolveRelative(src: string) {
  return new URL(src, import.meta.url).pathname;
}

async function resolveFile(ctx: PluginContext, f: string) {
  //const index = await resolveIndexHtml(ctx);
  //return path.join(path.dirname(index), f);
  return path.resolve(f);
}

async function resolveIndexHtml(ctx: PluginContext) {
  const index = await ctx.resolve("/index.html");
  if (!index) throw new Error("Can't resolve index.html");
  return index.id;
}

interface MetaInfo {
  meta: object;
}

interface WrapperInfo extends MetaInfo {
  meta: {
    wrapper: Wrapper;
    wrapped: string;
  };
}

function getSSRChunk(bundle: OutputBundle) {
  const chunk = Object.values(bundle)
    .filter(isOutputChunk)
    .find((c) => c.name === "ssr");

  if (!chunk) throw new Error("Can't find SSR chunk.");
  return chunk;
}

function isOutputChunk(chunk: OutputAsset | OutputChunk): chunk is OutputChunk {
  return chunk.type === "chunk";
}

function getCssUrls(serverAssets: OutputBundle, base = "/") {
  return Object.keys(serverAssets)
    .filter((f) => f.endsWith(".css"))
    .map((f) => `${base}${f}`);
}

function isMetaInfo(obj: unknown): obj is MetaInfo {
  return !!obj && typeof obj === "object" && "meta" in obj;
}

function isWrapperInfo(obj: unknown): obj is WrapperInfo {
  if (isMetaInfo(obj)) {
    const { meta } = obj;
    return (
      !!meta &&
      typeof meta === "object" &&
      "wrapper" in meta &&
      "wrapped" in meta
    );
  }
  return false;
}
